##############
# CNN Models #
##############
class CNN:
    def __init__(self, y, width, height, channel, model=0):
        self.y=y
        self.width=width
        self.height=height
        self.channel=channel
        self.model=model
        self.img_size=[width, height, channel]
    
    def model_one(self):
        print("CNN model 1")
        model = Sequential()
        model.add(Conv2D(filters=32,  kernel_size=(3,3), activation='relu',
                         padding='same', input_shape=self.img_size))
        model.add(Conv2D(filters=32, kernel_size=(3,3), activation='relu', padding='same'))
        model.add(MaxPooling2D(pool_size=(2, 2)))
        model.add(Dropout(rate=0.25))
        
        model.add(Conv2D(filters=64,  kernel_size=(3,3), activation='relu', padding='same'))
        model.add(Conv2D(filters=64, kernel_size=(3,3), activation='relu', padding='same'))
        model.add(MaxPooling2D(pool_size=(2, 2)))
        model.add(Dropout(rate=0.25))
        model.add(Flatten())
        
        model.add(Dense(units=512, activation='relu'))
        model.add(Dropout(rate=0.20))
        model.add(Dense(units=self.y.max()+1, activation='softmax'))
        
        model.compile(loss='categorical_crossentropy',
                      optimizer='adam',
                      metrics=['accuracy'])
        self.model=model
    
    def model_two(self):
        print("CNN model 2")
        model = Sequential()
        model.add(Conv2D(32, (3, 3), activation='relu', padding='same', name='conv_1',
                         input_shape=self.img_size))
        model.add(MaxPooling2D((2, 2), name='maxpool_1'))
        model.add(Conv2D(64, (3, 3), activation='relu', padding='same', name='conv_2'))
        model.add(MaxPooling2D((2, 2), name='maxpool_2'))
        model.add(Conv2D(128, (3, 3), activation='relu', padding='same', name='conv_3'))
        model.add(MaxPooling2D((2, 2), name='maxpool_3'))
        model.add(Conv2D(128, (3, 3), activation='relu', padding='same', name='conv_4'))
        model.add(MaxPooling2D((2, 2), name='maxpool_4'))
        model.add(Flatten())
        model.add(Dropout(0.5))
        
        model.add(Dense(512, activation='relu', name='dense_1'))
        model.add(Dropout(rate=0.20))
        model.add(Dense(units=self.y.max()+1, activation='softmax'))
        
        model.compile(optimizer='adam',
                      loss='binary_crossentropy',
                      metrics=['accuracy'])
        self.model=model

#################
# Visualization #
#################
def plot_loss_accuracy(hist, outfile):
    acc = hist.history['accuracy']
    val_acc = hist.history['val_accuracy']
    loss = hist.history['loss']
    val_loss = hist.history['val_loss']
    
    fig, (ax1, ax2) = plt.subplots(2, sharex=True)
    ax1.plot(acc, label='Training Accuracy')
    ax1.plot(val_acc, label='Validation Accuracy')
    ax1.legend(loc='lower right')
    ax1.set_ylabel('Accuracy')
    ax1.set_ylim(0, 1.0) #([min(plt.ylim()),1])
    
    ax2.plot(loss, label='Training Loss')
    ax2.plot(val_loss, label='Validation Loss')
    ax2.legend(loc='upper right')
    ax2.set_ylabel('Cross Entropy')
    ax2.set_xlabel('epoch')
    fig.show()
    fig.savefig(outfile)

def plot_confusion_matrix(model, X, y):
    y_pred = model.predict_classes(X, verbose=0)
    plt.figure(figsize=(8, 6))
    sns.heatmap(pd.DataFrame(confusion_matrix(y, y_pred)), annot=True, fmt='d', cmap='YlGnBu', alpha=0.8, vmin=0)
    
#############
# Load Data #
#############
import pandas as pd
import os
from pathlib import Path
import numpy as np
import matplotlib.pyplot as plt
import pickle
import sys

from sklearn.model_selection import train_test_split

import tensorflow.keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPooling2D

# Load data from TCGA Hilberts
PDIR='/cluster/projects/pughlab/projects/cancer_cell_lines/TCGA'
DATADIR = os.path.join(PDIR, "data")
OUTDIR = os.path.join(PDIR, "models")
IMG_SIZE=300
model_type=sys.argv[0]

pickle_X = open(os.path.join(DATADIR, "X.pickle"), "rb")
pickle_y = open(os.path.join(DATADIR, "y.pickle"), "rb")
X = pickle.load(pickle_X)
y = pickle.load(pickle_y)
#X = np.array(X).reshape(-1, IMG_SIZE, IMG_SIZE, 3)

img = plt.imshow(X[0])
plt.savefig(os.path.join(OUTDIR, "test.png"))


x_train,x_test,y_train,y_test=train_test_split(X,y,test_size=0.2)

# Load CIFAR-10 and format data
#(x_train2, y_train2), (x_test2, y_test2) = cifar10.load_data()

# One-hot encoding of y
y_train_one_hot = tensorflow.keras.utils.to_categorical(y_train, y.max()+1)
y_test_one_hot = tensorflow.keras.utils.to_categorical(y_test, y.max()+1)

# Format
x_train = x_train.astype('float32')
x_test = x_test.astype('float32')
x_train = x_train / 255
x_test = x_test / 255

#################
# Build/Train ConvNet #
#################


M=CNN(y, width=IMG_SIZE, height=IMG_SIZE, channel=3)
if model_type=='model1':
    M.model_one()
elif model_type=='model2':
    M.model_two()
    
hist = M.model.fit(x_train, y_train_one_hot,
                 batch_size=32, epochs=40,
                 validation_split=0.2)
plot_loss_accuracy(hist. os.path.join(OUTDIR, model_type, "cnn_performance.png"))
M.model.evaluate(x_test, y_test_one_hot)[1]
M.model.save(os.path.join(OUTDIR, model_type, 'my_tcga_model_layer2.h5'))

#y_pred_class = M.model.predict_classes(X_test, verbose=0)
#y_test_class = np.argmax(y_test, axis=1)
#plot_confusion_matrix(M.model, x_test, y_test_one_hot)
